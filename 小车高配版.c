/*****************************************************************
*  名称：小车前进+循迹+避障+红外遥控+蓝牙遥控+超声波避障（不带舵机）+物体跟随+ 超声波避障（带舵机）
*  淘宝：dianzi.taobao.com      
*  日期：2018年10月10日
*  抖音: Elecfans
*  晶振: 11.0592MHZ（因为有蓝牙控制，晶振必须要11.0592M）
******************************************************************/

/******************************************************************
                        头文件
******************************************************************/
#include<AT89X52.H>		          //包含51单片机头文件，内部有各种寄存器定义
#include <intrins.h>
#define uint    unsigned int      //重定义无符号整数类型
#define uchar   unsigned char     //重定义无符号字符类型
	
/*******************************************************************************************
                        电机驱动引脚定义
*******************************************************************************************/	
#define Left_moto_pwm	  P1_0	                //PWM信号端
#define Right_moto_pwm	  P1_5	                //PWM信号端
#define Right_moto_go    {P1_1=1,P1_2=0;}       //右电机向前走	   
#define Right_moto_back  {P1_1=0,P1_2=1;} 	    //右边电机向后转
#define Right_moto_Stop  {P1_1=0,P1_2=0;}       //右边电机停转                    
#define Left_moto_go     {P1_3=0,P1_4=1;}	      //左边电机向前走	 
#define Left_moto_back   {P1_3=1,P1_4=0;}	      //左边电机向后走
#define Left_moto_Stop   {P1_3=0,P1_4=0;}       //左边电机停转   

/******************************************************************
                       蓝牙控制码
******************************************************************/
#define left     'C'	 //接收到手机端发送的字符 C ，下车左转标志
#define right    'D'	 //接收到手机端发送的字符 D ，下车右转标志
#define up       'A'	 //接收到手机端发送的字符 A ，下车前进标志
#define down     'B'	 //接收到手机端发送的字符 B ，下车后退标志
#define stopp    'F'	 //接收到手机端发送的字符 F ，下车停车标志

/*******************************************************************************************
                                避障引脚定义  
*******************************************************************************************/	
#define Left_bizhang_led          P2_0	 //左避障传感器	  
#define Right_bizhang_led         P1_6	 //右避障传感器	
	
/*******************************************************************************************
                                 循迹引脚定义
*******************************************************************************************/
#define Left_xunji_led            P3_7	 //左循迹传感器    
#define Right_xunji_led           P1_7	 //右循迹传感器 
	
/*******************************************************************************************
                                 红外接收引脚定义
*******************************************************************************************/
sbit IR1838IN=P3^2;  

/******************************************************************
                         超声波模块引脚定义
******************************************************************/
#define  TRIG  P3_5
#define  ECHO  P3_6  

/**********************************************************************************************
                                    舵机信号线（橙色）
**********************************************************************************************/
#define Sevro_moto_pwm     P3_4	                                     
 
/*******************************************************************************************
                                 蜂鸣器引脚定义
*******************************************************************************************/	
sbit BUZZ=P2^1;

/*******************************************************************************************
                                模式指示灯LED引脚定义
*******************************************************************************************/	
sbit LED=P2^2;                            

/*******************************************************************************************
                                 变量定义
*******************************************************************************************/	
unsigned char pwm_val_left  =0; //变量定义
unsigned char push_val_left =0; // 左电机占空比N/20
unsigned char pwm_val_right =0; //变量定义
unsigned char push_val_right=0; // 右电机占空比N/20

uchar code  RecvData[]={0x40,0x19,0x07,0x09,0x15};		//红外键码
uchar IRCOM[7];

bit  flag_REC=0; 		    ///蓝牙相关
bit  flag    =0;  
unsigned char  L=0;
unsigned char  dat=0;
unsigned char  buff[5]=0; //接收缓冲字节

//超声波壁障不带舵机相关 		  
unsigned int  time=0;                 //用于存放定时器时间值
unsigned long S=0;                    //用于存放距离的值

//超声波壁障带舵机相关
unsigned char pwm_val_Sevro  = 0;  //变量定义
unsigned char push_val_Sevro =14;  //舵机归中，产生约，1.5MS 信号
unsigned long S1=0;				   //存放前方距离值
unsigned long S2=0;				   //存放右边距离
unsigned long S3=0;				   //存放左边
unsigned int  timer=0;			   //延时基准变量

bit  flag_zd =0;				   //定时器0中断函数标志
	
/****************************************************************************************
**                                 延时函数1
*****************************************************************************************/
void Delay10us(unsigned char i) 
{ 
	unsigned char j; 
	do{ 
		j = 10; 
		do{ 
		 _nop_(); 
		 }while(--j); 
	}while(--i); 
}  
/*******************************************************************************************
**                                 延时函数2
*******************************************************************************************/
void delay_nus(unsigned int i)  
{ 
   i=i/10;
   while(--i);
} 
/*******************************************************************************************
**                                 延时函数3
*******************************************************************************************/
void delay_nms(unsigned int n)   
{ 
   n=n+1;
   while(--n)  
   delay_nus(900);               
}
/*******************************************************************************************
**                                 延时函数4（红外用）
*******************************************************************************************/
void delayms(unsigned char x)                         
{
  unsigned char i;                                    
  while(x--)                                          
  {
    for (i = 0; i<13; i++) {}                        
  }
} 
/*******************************************************************************************
**                                 蜂鸣器响一声的函数
*******************************************************************************************/ 
void speak()
{    
   BUZZ=0;delay_nms(200);BUZZ=1; 	
}  
/*******************************************************************************************
**                                 LED闪烁次数函数
*******************************************************************************************/
void LEDlight(unsigned int k)	   //k等于多少就闪烁几次
{    
  unsigned int x;
  for(x=0;x<k;x++)
	{LED=0;delay_nms(200);LED=1;delay_nms(200);} 	
}
/*******************************************************************************************
**                                    小车前进函数
*******************************************************************************************/
void  run(void)
{
	 Left_moto_go ;        //左电机往前
	 Right_moto_go ;       //右电机往前
}
/*******************************************************************************************
**                                    小车后退函数
*******************************************************************************************/ 
void  backrun(void)
{
	 Left_moto_back;      //左电机往后
	 Right_moto_back;     //右电机往后
}
/*******************************************************************************************
**                                    小车左转函数
*******************************************************************************************/
void  leftrun(void)
{	 
	 Left_moto_back;   //左电机往后
   Right_moto_go;    //右电机往前
}
/*******************************************************************************************
**                                    小车右转函数
*******************************************************************************************/
void  rightrun(void)
{ 
   Right_moto_back;   //右电机向后
	 Left_moto_go;     //左电机向前
}
/*******************************************************************************************
**                                    小车停车函数
*******************************************************************************************/
void  stop(void)
{    
	 Left_moto_Stop;   //左电机停止
	 Right_moto_Stop;  //右电机停止
}

/*******************************************************************************************
**                                    左电机PWM调速
*******************************************************************************************/
void pwm_out_left_moto(void)
{  
      if(pwm_val_left<=push_val_left)
	     {
		     Left_moto_pwm=1; 
		  }
	  else 
	     {
	       Left_moto_pwm=0; 
		  }
	  if(pwm_val_left>=20)
	      pwm_val_left=0;
}
/*******************************************************************************************
**                                    右电机PWM调速   
*******************************************************************************************/
void pwm_out_right_moto(void)
{ 
     if(pwm_val_right<=push_val_right)
	    {
	       Right_moto_pwm=1; 
		 }
	 else 
	    {
		   Right_moto_pwm=0;
		 }
	 if(pwm_val_right>=20)
	     pwm_val_right=0;
}  

/*******************************************************************************************
**                                 小车前进测试函数
*******************************************************************************************/
void runtest()                     
{
  push_val_left =10;    //速度调节变量 0-20，0最小，20最大 ，需根据实际情况决定最小值是多少
  push_val_right=10;   //速度调节变量 0-20，0最小，20最大
  run();
  delay_nms(100);
}
   
/*******************************************************************************************
**                                 小车循迹函数
*******************************************************************************************/
void Car_Traction()                     
{
   push_val_left =12;    //速度调节变量 0-20，0最小，20最大 ，需根据实际情况决定最小值是多少
   push_val_right=12;   //速度调节变量 0-20，0最小，20最大

   if(Left_xunji_led  == 0 && Right_xunji_led == 0)        //左右两边均没有识别到黑线
   {
      run(); 											   //小车前进
	    BUZZ=1;                                              //蜂鸣器不响
      delay_nms (10);	  
   }
   else if(Left_xunji_led  == 0 && Right_xunji_led == 1)   //右边遇黑线
   {
      rightrun();										   //小车右转
	    BUZZ=0;                                          	   //蜂鸣器响
      delay_nms (60);
   }
   else if(Left_xunji_led  == 1 &&  Right_xunji_led == 0)  //左边遇黑线
   {
      leftrun();   										   //小车左转
	    BUZZ=0;                                         	   //蜂鸣器响
      delay_nms (60);
   }
   else if(Left_xunji_led  == 1 &&  Right_xunji_led == 1)  //左右都遇到黑线
   {    
	    stop(); 											   //停车
	    BUZZ=1;                                              //蜂鸣器不响
      delay_nms (10);
   }    
}

/*******************************************************************************************
**                                 小车避障函数
*******************************************************************************************/
void Car_Avoidance()                   
{	  
	push_val_left =15;    //速度调节变量 0-20，0最小，20最大 ，需根据实际情况决定最小值是多少
    push_val_right=15;   //速度调节变量 0-20，0最小，20最大

	if(Left_bizhang_led==1&&Right_bizhang_led ==1)	          //前方无障碍
	  {	 
		run(); 
		BUZZ=1;                                               //前进
		delay_nms (10);		
	  }
	else
	  {			  
		if(Left_bizhang_led==1&&Right_bizhang_led ==0)	    //右前方有障碍
		  {
			leftrun();    
			BUZZ=0;                                         //左转
			delay_nms (100);					            
		  }	 
		if(Right_bizhang_led ==1&&Left_bizhang_led==0)		//左前方有障碍
		  {	  	
			rightrun();  
			BUZZ=0;                                         //右转
			delay_nms (100);					                    
		  }
		if(Right_bizhang_led==0&&Left_bizhang_led==0)		//左右前方都有障碍
		  {	  
			BUZZ=0;
			stop();                                         //停车
			delay_nms (50);							    //停车反冲
			BUZZ=1;			                    		    
			backrun(); 		                                //后退
			delay_nms (150);		                        //延时300ms
			rightrun();  		                            //右转
			delay_nms (150);								//延时300ms
		  }
	   }		  
}
 
/*******************************************************************************************
**                                 红外解码控制小车子函数
*******************************************************************************************/
void Control_Car(unsigned char RunType)    
{
   push_val_left =15;    //速度调节变量 0-20，0最小，20最大 ，需根据实际情况决定最小值是多少
   push_val_right=15;   //速度调节变量 0-20，0最小，20最大

   switch(RunType)                           //判断小车动作类型
	 {
	   case 0:                               
		{ 
		  stop();                            //前进
		  speak();							 //蜂鸣器响一声
		  run();	                         //前进
		  break;
		}
	   case 1:                                 
		{ 
	  	  stop();                             //后退
		  speak(); 	 					  //蜂鸣器响一声
		  backrun();                          //后退
		  break;
		}
	   case 2:                                      
		{ 
		  stop();                             //左转 		    
		  speak(); 						  //蜂鸣器响一声 
		  leftrun();	                   //左转
		  break;
		}
	   case 3:                                
		{ 
		  stop();                             //右转
		  speak();							  //蜂鸣器响一声
		  rightrun();	                      //右转函数 
		  break;
	    }
	   case 4:                               
		{
		  stop();                             //停车
		  speak();							  //蜂鸣器响一声
		  break; 
		}
	 }
}
/*******************************************************************************************
**                                 小车蓝牙控制函数
*******************************************************************************************/
void lanyaKZ()
{
   push_val_left =15;    //速度调节变量 0-20，0最小，20最大 ，需根据实际情况决定最小值是多少
   push_val_right=15;   //速度调节变量 0-20，0最小，20最大

   flag_REC=0;
   if(buff[0]=='O'&&buff[1]=='N')	//第一个字节为O，第二个字节为N，第三个字节为控制码
   switch(buff[2])		            //判断小车动作类型
    {
      case up :	  run();			//前进
				  break;

	  case down:  backrun();	   //后退							
				  break;

      case left:  leftrun();	   //左转
				  break;
				  
      case right: rightrun();	   //右转	   
				  break;
				  
	  case stopp: stop();		   //停车
				  break; 			  
     }				 
}

/*******************************************************************************************
**                                 超声波模块测距函数
*******************************************************************************************/
void qidongceju()      //超声波测距
{
   TRIG=1;			   //启动超声波模块
   Delay10us(2);
   TRIG=0;
   while(!ECHO);	   //当ECHO为零时等待
   TR1=1;			   //开启计数
   while(ECHO);		   //当ECHO为1计数并等待
   TR1=0;			   //关闭计数
   time=TH1*256+TL1;   //读取时间
   TH1=0;			   //定时器1重新赋值
   TL1=0;
   S=(time*1.7)/100;   //算出来是CM
}
/*******************************************************************************************
                                超声波避障函数（不带舵机）
*******************************************************************************************/
void chaoshengbo()   //超声波避障（不带舵机）
{
   push_val_left =15;    //速度调节变量 0-20，0最小，20最大 ，需根据实际情况决定最小值是多少
   push_val_right=15;   //速度调节变量 0-20，0最小，20最大

   qidongceju();	 //测出前方距离

   if(S<=10)	     //如果距离小于等于20cm
	 {		
		stop();				  //先停车			
		speak();               //蜂鸣器响           
		backrun();            //小车后退
		delay_nms (200); 	      //延时200MS，后退一小段距离  
		rightrun();         //前进右转
		delay_nms (200); 	      //右转转400MS
	 }
   else				 //如果距离大于20cm
	 {
		run();                //小车保持前进
	 }
}
/*******************************************************************************************
**                                 物体跟随控制函数
*******************************************************************************************/
void wutigensui()
{
   push_val_left =15;    //速度调节变量 0-20，0最小，20最大 ，需根据实际情况决定最小值是多少
   push_val_right=15;   //速度调节变量 0-20，0最小，20最大

   qidongceju();	    //启动超声波测出前方距离

   if(S<5)		        //如果距离小于5cm
     {
	   backrun();	    //小车后退
     }
   else if(S>=5&S<=10)  //如果距离在5-10cm之间，小车停止
     {
	   stop();
     }
   else if(S>10&S<40)   //如果距离在10-40cm之间，小车向前
     {
	   run();
     }
   else					//如果距离大于40cm。小车停止
     {
	   stop();
	 }
}
/*******************************************************************************************
**                                 超声波避障（带舵机）控制函数
*******************************************************************************************/
 void  COMM( void ) //障碍判断		      
  {
		  push_val_Sevro=6;	  //舵机向右转
		  timer=0;
		  while(timer<=4000); //延时400MS让舵机转到其位置		 
		  qidongceju();		  //启动超声波测距计算距离
		  S2=S;  			  //存储右边距离
  		 
		  push_val_Sevro=20;  //舵机向左转
		  timer=0;
		  while(timer<=4000); //延时400MS让舵机转到其位置
		  qidongceju();       //启动超声波测距计算距离
		  S3=S; 			  //存储左边距离
		  
		  push_val_Sevro=14;  //舵机归中
		  timer=0;
		  while(timer<=4000); //延时400MS让舵机转到其位置
		  qidongceju();       //启动超声波测距计算距离
		  S1=S; 		      //存储正前方距离

          if((S2<15)||(S3<15))  //左边或者右边的距离小于15cm
		  {
		     backrun();		    //小车后退
		     timer=0;
		     while(timer<=1000);	//后退一段时间
		  }
		   
		  if(S2>S3)		 		 //如果右边距离大于左边距离
		     {
				rightrun();  	 //车的左边比车的右边距离小，右转	
		        timer=0;
		        while(timer<=1500);
		     }				      
		       else				 //如果右边距离小于左边距离
		     {
		       leftrun();		 //车的左边比车的右边距离大，左转
		       timer=0;
		       while(timer<=1500);
		     }		  			  
}
void duojibizhang()
{
  if(timer>=200)	  //20MS检测启动检测一次
	   {
	       timer=0;
		   qidongceju();  //启动超声波测出前方距离
           if(S<15)		  //如果距离小于15CM
		   {
		     stop();	  //小车停止
		     COMM(); 	  //进入方向函数，测出左中右三个方向的距离，控制小车行进方式
		   }
		   else			  //如果距离大于15cm，小车前进
		   {
		     run();
		   }
	   }
}
/*******************************************************************************************
**                                        各个功能定时器初始化
*******************************************************************************************/
void tiaoshuPWM()	 //电机PWM调速初始化
{
  TMOD=0X21;	//定时器0为方式1，产生PWM
  TH0= 0XFc;    //1ms定时，PWM初始化
  TL0= 0X18;
  TR0= 1;		//开启定时器0
  ET0= 1;		//开启定时器0中断
  EA=1; 	    //开总中断
  flag_zd =0;	//定时器1进入PWM调速函数
}
void HWmoshi()	  //红外中断初始化
{
  EX0=1;          //同意开启外部中断1
  IT0=1; 		  //设定外部中断1为低边缘触发类型
  EA=1;            
}
void lanya()
{
  TMOD=0X21;	//定时器1为模式2，自动赋初值
  TH1=0xFd;  	//蓝牙初始化 11.0592M晶振，9600波特率
  TL1=0xFd;
  SCON=0x50;  
  PCON=0x00; 
  TR1=1;
  ES=1;  	   //开启串口中断
  EA=1;
  ET1=0; 	   //关闭定时器1中断
}
void csbint()  //超声波模块定时中断初始化
{
  TMOD=0X11;
  TH1=0;
  TL1=0;           
  EA=1; 
  ET1=1;             				                   
}
void duojiint()	  //舵机模块定时中断初始化
{
  TMOD=0X11;
  TH0=(65536-100)/256;	  //100US定时
  TL0=(65536-100)%256;
  TR0= 1; 
  ET0= 1;
  EA=1; 	   
  EX0=0;
  ES=0;
  flag_zd=1;		      //定时器1进入舵机信号产生函数
  Left_moto_pwm=1;		  //占空比=100%，左电机全速
  Right_moto_pwm=1;		  //占空比=100%，右电机全速
  delay_nms (50);
  push_val_Sevro=14;	  //舵机归中
  delay_nms (500); 
}
void duojiguizhong()	  //舵机上电后回归正前方位置初始化
{
  flag_zd=1;		      //定时器1进入舵机信号产生函数 
  TMOD=0X11;
  TH0=(65536-100)/256;	  //100US定时
  TL0=(65536-100)%256;
  TR0= 1; 
  ET0= 1;
  EA=1; 	   
  delay_nms (50);
  push_val_Sevro=14;	  //舵机归中
  delay_nms (500);
}
/*******************************************************************************************
**                          中断服务子函数
*******************************************************************************************/
void IR1838_IN() interrupt 0 using 0                  
{
  unsigned char j,k,N=0;                              //定义临时接收变量
  EX0 = 0;                                            //关闭外部中断  
  delayms(15);                                        //消抖
  if (IR1838IN==1)                                    
  {  
     EX0 =1;                                          //外部中断开
	 return;                                          //返回
  }                         
  while (!IR1838IN)                                   //等IR1838IN变为高电平，跳过9ms的前导低电平信号。
  {
     delayms(1);                                     //延时等待
  }

  for (j=0;j<4;j++)                                   //采集红外遥控器数据
  { 
    for (k=0;k<8;k++)                                 //分四次采集8位数据
    {
       while (IR1838IN)                               //等IR1838IN变为低电平，跳过4.5ms的前导高电平信号。
       {
         delayms(1);                                  //延时等待
       }
       
       while (!IR1838IN)                              //等IR1838IN变为高电平
       {
         delayms(1);                                  //延时等待
       }
       while (IR1838IN)                               //计算IR1838IN高电平时长
       {
         delayms(1);                                  //延时等待
         N++;                                         //计数器加加
         if (N>=30)                                   //判断计数器累加值
	     { 
           EX0=1;                                     //打开外部中断功能
	       return;                                      //返回
         }                   
       }
                                       
      IRCOM[j]=IRCOM[j] >> 1;                         //进行数据位移操作并自动补零
      if (N>=8)                                       //判断数据长度 
      {
         IRCOM[j] = IRCOM[j] | 0x80;                  //数据最高位补1
      } 
      N=0;                                            //清零位数计录器
    }
  } 
  if (IRCOM[2]!=~IRCOM[3])                            //判断地址码是否相同
  { 
     EX0=1;                                           //打开外部中断
     return;                                          //返回
  }
  for(j=0;j<10;j++)                                   //循环进行键码解析
   {
      if(IRCOM[2]==RecvData[j])                       //进行键位对应
      {
        Control_Car(j);                               
      }
   }
  EX0 = 1;                                           //外部中断开 
} 
 
void timer0()interrupt 1	using 0  //定时器0中断服务函数
{
   if(flag_zd==0)   //这里进入PWM调速
   {
     TH0=0XFc;	  //1Ms定时
	 TL0=0X18;
	 pwm_val_left++;
	 pwm_val_right++;
	 pwm_out_left_moto();
	 pwm_out_right_moto();
   } 
  if(flag_zd==1)	 //这里进入舵机信号函数
   {
	 TH0=(65536-100)/256;	  //100US定时
	 TL0=(65536-100)%256;
	 timer++;				  //定时器100US为准。在这个基础上延时
	 pwm_val_Sevro++;
	 if(pwm_val_Sevro<=push_val_Sevro)
	    Sevro_moto_pwm=1; 
	 else 
	    Sevro_moto_pwm=0;
	 if(pwm_val_Sevro>=100)
	    pwm_val_Sevro=0;
	} 
 }	

void timer1() interrupt 3 	using 2	 ////定时器1中断服务函数
{
  
 }
void sint() interrupt 4	     //串口中断服务函数
{ 
    if(RI)	                 //是否接收中断
    {
       RI=0;
       dat=SBUF;
       if(dat=='O'&&(L==0))  //接收数据第一帧
         {
            buff[L]=dat;
            flag=1;          //开始接收数据
         }
       else
       if(flag==1)
			 {
				L++;
				buff[L]=dat;
				if(L>=2)
				{L=0;flag=0;flag_REC=1 ;}  // 停止接收
			 }
	 }
}
/*******************************************************************************************
**                                        主函数
*******************************************************************************************/
void main()                      //主程序入口
{
  unsigned char temp = 1;		//temp=1，通电即进入循迹模式，预先什么模式，还需要把这个模式的初始化放到duojiguizhong();下面
  duojiguizhong();			    //让舵机回归正前方位置
  tiaoshuPWM(); 				//电机调速初始化
  speak();	                    //蜂鸣器发出“滴”声响
  LEDlight(1);                  //LED闪烁1次
  while(1)                      //程序主循环
  {
	if(P3_3 == 0)			//如果按键被按下
	  {
	    delay_nms(10);		//延时消抖
	    if(P3_3 == 0)		//再次确认按键被按下
		  {	 
		    stop();			//停车，进入模式切换
			speak();        //蜂鸣器响一声
			TR0= 0;			//都先关闭定时器
			TR1= 0;
			temp++;			//temp+1
			while(!P3_3);	//等待按键松开
		  }
		
		if(temp >8)			//如果temp大于7，temp重新等于1
	      {
		    temp = 1;
	      }

		if(temp == 1)      //循迹模式
	      {
		    tiaoshuPWM();
	        LEDlight(1);   //LED闪烁1次
	      }

	    if(temp == 2)      //循迹模式
	      {
		    tiaoshuPWM();
	        LEDlight(2);   //LED闪烁1次
	      }
	    if(temp == 3)      //避障模式
	      {
		    tiaoshuPWM();
	        LEDlight(3);   //LED闪烁2次
	      }
	    if(temp == 4)      //红外遥控模式
	      {
		    tiaoshuPWM();
		    HWmoshi();	   //按键中断初始化
	        LEDlight(4);   //LED闪烁3次
	      }	
		if(temp == 5)      //蓝牙遥控模式
	      {
		    tiaoshuPWM();
			lanya();	   //蓝牙波特率产生初始化
	        LEDlight(5);   //LED闪烁4次
	      }
		if(temp == 6)      //超声波避障模式（不带舵机）
	      {
		    tiaoshuPWM();
		    csbint();
	        LEDlight(6);   //LED闪烁5次
	      }	
		if(temp == 7)      //超声波物体跟随模式（不带舵机）
	      {
		   	tiaoshuPWM();
		    csbint();	   //跟超声波避障不带舵机共用一个初始化
	        LEDlight(7);   //LED闪烁6次
	      }	
		if(temp == 8)      //超声波避障模式（带舵机）
	      {
		    LEDlight(8);   //LED闪烁7次
		    csbint();	   //跟超声波避障不带舵机共用一个初始化
			duojiint();
	        	
	      }		    	    	    	    
	  }	
	switch(temp)		   //判断temp等于多少，进入相应的行车模式
	  {
	    case 1:	runtest();       break;	  //进入前进测试模式
		case 2:	Car_Traction() ; break;	  //进入循迹模式
		case 3: Car_Avoidance(); break;	  //进入避障模式
		case 4:                  break;	  //进入红外遥控模式
		case 5: lanyaKZ();       break;	  //进入蓝牙遥控模式
		case 6: chaoshengbo();   break;	  //进入超声波避障（不带舵机）模式
		case 7: wutigensui();    break;	  //进入物体跟随模式
		case 8: duojibizhang();  break;	  //进入超声波避障（带舵机）模式
	  }  
  }
}
/*******************************************************************************************
**                                         结束
*******************************************************************************************/